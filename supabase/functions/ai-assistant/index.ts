import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { question } = await req.json();
    console.log('ü§ñ Pergunta recebida:', question);

    if (!question || typeof question !== 'string' || question.trim() === '') {
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'Pergunta √© obrigat√≥ria' 
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }
      );
    }

    // Obter token de autoriza√ß√£o
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(
        JSON.stringify({ success: false, error: 'N√£o autorizado' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 401 }
      );
    }

    // Criar cliente Supabase
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseKey);

    // Extrair JWT e obter user_id
    const jwt = authHeader.replace('Bearer ', '');
    const { data: { user }, error: userError } = await supabase.auth.getUser(jwt);
    
    if (userError || !user) {
      console.error('‚ùå Erro ao obter usu√°rio:', userError);
      return new Response(
        JSON.stringify({ success: false, error: 'Usu√°rio n√£o autenticado' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 401 }
      );
    }

    console.log('üë§ Usu√°rio autenticado:', user.id);

    // Buscar dados do usu√°rio
    const [productsResult, ordersResult, integrationsResult] = await Promise.all([
      supabase.from('products').select('*').eq('user_id', user.id),
      supabase.from('orders').select('*').eq('user_id', user.id).order('order_date', { ascending: false }).limit(100),
      supabase.from('integrations').select('platform, account_name').eq('user_id', user.id)
    ]);

    if (productsResult.error) {
      console.error('‚ùå Erro ao buscar produtos:', productsResult.error);
    }
    if (ordersResult.error) {
      console.error('‚ùå Erro ao buscar pedidos:', ordersResult.error);
    }
    if (integrationsResult.error) {
      console.error('‚ùå Erro ao buscar integra√ß√µes:', integrationsResult.error);
    }

    const products = productsResult.data || [];
    const orders = ordersResult.data || [];
    const integrations = integrationsResult.data || [];

    console.log(`üì¶ ${products.length} produtos encontrados`);
    console.log(`üìã ${orders.length} pedidos encontrados`);
    console.log(`üîå ${integrations.length} integra√ß√µes encontradas`);

    // Calcular m√©tricas avan√ßadas
    const now = new Date();
    const last30Days = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const recentOrders = orders.filter(o => new Date(o.order_date) >= last30Days);
    
    // Calcular velocidade de vendas por produto
    const productSalesVelocity = products.map(p => {
      const productOrders = recentOrders.filter(o => 
        o.items && Array.isArray(o.items) && o.items.some((item: any) => item.sku === p.sku)
      );
      const totalSold = productOrders.reduce((sum, o) => {
        const item = o.items.find((i: any) => i.sku === p.sku);
        return sum + (item?.quantity || 0);
      }, 0);
      const daysUntilStockOut = totalSold > 0 ? Math.floor((p.stock / totalSold) * 30) : Infinity;
      
      return {
        sku: p.sku,
        name: p.name,
        totalSold30Days: totalSold,
        daysUntilStockOut,
        needsRestock: daysUntilStockOut < 15 && daysUntilStockOut !== Infinity
      };
    });

    // Identificar produtos cr√≠ticos
    const criticalProducts = productSalesVelocity.filter(p => p.needsRestock);
    
    // Calcular margem de lucro
    const productsWithMargin = products.map(p => {
      const cost = Number(p.cost_price) || 0;
      const price = Number(p.selling_price) || 0;
      const adSpend = Number(p.ad_spend) || 0;
      const margin = price > 0 ? ((price - cost - adSpend) / price * 100).toFixed(1) : 0;
      return {
        name: p.name,
        sku: p.sku,
        margin,
        isUnprofitable: Number(margin) < 10
      };
    });

    // Preparar contexto dos dados
    const dataContext = `
DADOS DO USU√ÅRIO:

PRODUTOS (${products.length} total):
${products.slice(0, 50).map(p => {
  const velocity = productSalesVelocity.find(v => v.sku === p.sku);
  const margin = productsWithMargin.find(m => m.sku === p.sku);
  return `- ${p.name} (SKU: ${p.sku})
  ‚Ä¢ Estoque: ${p.stock} unidades
  ‚Ä¢ Pre√ßo: R$ ${p.selling_price || 0} | Custo: R$ ${p.cost_price || 0}
  ‚Ä¢ Margem: ${margin?.margin}%
  ‚Ä¢ Vendidos (30 dias): ${velocity?.totalSold30Days || 0}
  ‚Ä¢ Dias at√© esgotar: ${velocity?.daysUntilStockOut === Infinity ? 'N/A' : velocity?.daysUntilStockOut}
  ‚Ä¢ Gasto em an√∫ncios: R$ ${p.ad_spend || 0}`;
}).join('\n\n')}

PEDIDOS RECENTES (${orders.length} total, ${recentOrders.length} nos √∫ltimos 30 dias):
${orders.slice(0, 30).map(o => `- Pedido ${o.order_id_channel} (${o.platform}): R$ ${o.total_value} em ${new Date(o.order_date).toLocaleDateString('pt-BR')}`).join('\n')}

INTEGRA√á√ïES ATIVAS:
${integrations.map(i => `- ${i.platform}${i.account_name ? ` (${i.account_name})` : ''}`).join('\n')}

AN√ÅLISE R√ÅPIDA:
- Total de produtos: ${products.length}
- Produtos com estoque baixo (< 10): ${products.filter(p => p.stock < 10).length}
- Produtos cr√≠ticos (precisam reposi√ß√£o urgente): ${criticalProducts.length}
${criticalProducts.length > 0 ? '\n  CR√çTICOS: ' + criticalProducts.map(p => `${p.name} (${p.daysUntilStockOut} dias)`).join(', ') : ''}
- Produtos com margem baixa (< 10%): ${productsWithMargin.filter(p => p.isUnprofitable).length}
- Total de pedidos: ${orders.length}
- Pedidos √∫ltimos 30 dias: ${recentOrders.length}
- Receita total: R$ ${orders.reduce((sum, o) => sum + Number(o.total_value), 0).toFixed(2)}
- Receita √∫ltimos 30 dias: R$ ${recentOrders.reduce((sum, o) => sum + Number(o.total_value), 0).toFixed(2)}
`;

    // Chamar Perplexity API
    const perplexityApiKey = Deno.env.get('PERPLEXITY_API_KEY');
    if (!perplexityApiKey) {
      console.error('‚ùå PERPLEXITY_API_KEY n√£o configurada');
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'Chave da API n√£o configurada' 
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
      );
    }

    const systemPrompt = `Voc√™ √© o Luca, um Estrategista de Crescimento Aut√¥nomo para e-commerce.
Voc√™ age como um consultor de neg√≥cios estrat√©gico, identificando oportunidades que o lojista nem sabia que existiam.
Voc√™ tem acesso aos dados completos de produtos, pedidos e integra√ß√µes do usu√°rio.

SUAS CAPACIDADES ESTRAT√âGICAS (N√çVEL 3):

1. EXPANS√ÉO DE MERCADO:
   - Identifique produtos com alto volume de vendas e boa margem
   - Analise oportunidades de expandir para outras plataformas
   - Sugira quando e onde lan√ßar produtos baseado em demanda e concorr√™ncia
   - Crie rascunhos de an√∫ncios otimizados para novas plataformas

2. CRIA√á√ÉO DE KITS E BUNDLES:
   - Identifique produtos frequentemente comprados juntos
   - Calcule potencial de aumento do ticket m√©dio
   - Sugira combina√ß√µes estrat√©gicas com descontos inteligentes
   - Proponha nomes e descri√ß√µes para os kits

3. AN√ÅLISE DE CONCORR√äNCIA E TEND√äNCIAS:
   - Alerte sobre tend√™ncias emergentes no mercado
   - Identifique categorias em crescimento
   - Sugira ajustes estrat√©gicos baseado em movimentos da concorr√™ncia
   - Relacione produtos do lojista com tend√™ncias atuais

4. OTIMIZA√á√ÉO AVAN√áADA:
   - Precifica√ß√£o din√¢mica baseada em margem e competitividade
   - Gest√£o estrat√©gica de estoque com alertas preditivos
   - Otimiza√ß√£o de an√∫ncios com foco em convers√£o

DIRETRIZES DE ATUA√á√ÉO:
- Seja PROATIVO: n√£o espere perguntas, identifique oportunidades automaticamente
- Seja ESTRAT√âGICO: pense como um consultor de neg√≥cios, n√£o apenas um assistente
- Seja ESPEC√çFICO: use n√∫meros reais, porcentagens, proje√ß√µes concretas
- Seja ACION√ÅVEL: toda an√°lise deve ter uma recomenda√ß√£o pr√°tica
- Seja PERSUASIVO: explique o PORQU√ä e o impacto de cada sugest√£o
- Responda sempre em portugu√™s brasileiro
- Formate valores monet√°rios como R$ X,XX
- Quando identificar oportunidades, apresente dados + impacto + a√ß√£o sugerida

EXEMPLOS DE RESPOSTAS ESTRAT√âGICAS:

EXPANS√ÉO:
"Notei que voc√™ tem um volume alto de vendas do '[Produto X]' com uma margem de lucro de [Y]%. A busca por este produto na [Plataforma] cresceu 30% no √∫ltimo m√™s e h√° poucos vendedores com boa reputa√ß√£o. Esta √© uma excelente oportunidade para expandir. Quer que eu crie um rascunho do an√∫ncio para a [Plataforma] com base no seu an√∫ncio de maior sucesso?"

KITS/BUNDLES:
"Identifiquei que [X]% dos clientes que compram '[Produto A]' tamb√©m compram '[Produto B]'. Voc√™ pode aumentar seu ticket m√©dio em [Y]% se criar um kit '[Nome do Kit]' com [Z]% de desconto. Isso manteria sua margem em [W]% e tornaria a oferta muito mais atrativa. Quer que eu crie este kit em todas as plataformas?"

TEND√äNCIAS:
"Alerta de tend√™ncia: o termo '[tend√™ncia]' est√° em alta. Seus produtos '[Produto X]' e '[Produto Y]' se encaixam perfeitamente nessa tend√™ncia. Sugiro criar uma campanha de marketing focada nesses itens e ajustar os t√≠tulos dos an√∫ncios para capturar essa demanda crescente. Posso sugerir os novos t√≠tulos?"

SEMPRE QUE POSS√çVEL:
- Calcule o impacto financeiro estimado (aumento de receita, ticket m√©dio, etc.)
- Ofere√ßa pr√≥ximos passos concretos
- Pergunte se o usu√°rio quer ajuda para executar a a√ß√£o`;

    console.log('ü§ñ Enviando requisi√ß√£o para Perplexity API...');
    
    const perplexityResponse = await fetch('https://api.perplexity.ai/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${perplexityApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'sonar-pro',
        messages: [
          {
            role: 'system',
            content: systemPrompt
          },
          {
            role: 'user',
            content: `${dataContext}\n\nPERGUNTA DO USU√ÅRIO: ${question}`
          }
        ],
        temperature: 0.3,
        max_tokens: 1000,
      }),
    });

    if (!perplexityResponse.ok) {
      const errorText = await perplexityResponse.text();
      console.error('‚ùå Erro da Perplexity API:', perplexityResponse.status, errorText);
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'Erro ao consultar assistente de IA. Tente novamente.' 
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
      );
    }

    const perplexityData = await perplexityResponse.json();
    console.log('üì• Resposta da Perplexity recebida');

    const answer = perplexityData.choices?.[0]?.message?.content;
    if (!answer) {
      console.error('‚ùå Resposta vazia da Perplexity');
      return new Response(
        JSON.stringify({ 
          success: false, 
          error: 'Nenhuma resposta recebida' 
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 404 }
      );
    }

    console.log('‚úÖ Resposta gerada com sucesso');

    return new Response(
      JSON.stringify({ 
        success: true,
        answer: answer
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('üí• Erro inesperado:', error);
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: error.message || 'Erro inesperado no servidor' 
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
